# quadmesh Copilot Instructions

- **Purpose**: Adaptive 1D/2D quadtree FE toolkit for assembly, solving, plotting, and stochastic (GMRF) utilities.
- **Core layout**: `src/mesh.py` (trees, `QuadCell`/`Interval`, hanging nodes, reference maps, flags), `src/fem.py` (`QuadFE`, `DofHandler`, `Basis`, shape/derivative helpers), `src/function.py` (`Map`, `Nodal`, `Explicit`, `Constant`, interpolation), `src/assembler.py` (`Kernel`, `Form`/`IIForm`/`IPForm`, `GaussRule`, shape eval, integration over cells/half-edges), `src/solver.py` (`LinearSystem` constraints for Dirichlet + hanging nodes), `src/spd.py` (SPD + Cholesky, CHOLMOD/modified LDLT), `src/gmrf.py` (cov kernels, KL/GMRF helpers), `src/plot.py` (mesh/function visualization).
- **Imports/pathing**: Code assumes `src` on `PYTHONPATH`; tests hardcode `/home-hans-werner/git/quadmesh/src/`. When running locally, export `PYTHONPATH=$(pwd)/src` or prepend `sys.path` accordingly.
- **Elements & bases**: Use `QuadFE(dim, etype)` where `etype` in `{DQ0,Q1,Q2,Q3,...}` (`DQ*` = discontinuous). Build `DofHandler(mesh, element)` then `distribute_dofs()` and `set_dof_vertices()`. `Basis(dh, name)` carries trial/test identity; submeshes via `subforest_flag`.
- **Meshes**: `QuadMesh`/`Mesh1D` create adaptive trees (`cells.get_leaves()`, `refine`, `balance`). `mark(flag)` on cells/half-edges controls refinement/region selection. `convert_to_array` normalizes point inputs; respect dim inference.
- **Assembly pattern**: Define kernels via `Kernel([fields], derivatives=[...], F=callable)`, forms via `Form(trial=Basis, test=Basis, kernel=..., dmu={'dx','ds'}, flag=region_flag)`, optional `IIForm`/`IPForm` for interior/boundary penalties. Bundle forms (list) into `Assembler(problem, mesh)`. Quadrature via `GaussRule(order, element|shape)`; `scale_rule` for subcells; `shape_info` uses entity flags to select regions.
- **Derivatives**: Derivative tags parsed by `parse_derivative_info` (`'*x','*y','*xx',...`), and basis derivative names like `'vx','vy','ux','uy'` etc. Ensure derivative strings match helpers to avoid runtime asserts.
- **Linear systems**: Wrap assembled matrices in `LinearSystem(basis, A, b)`. Call `add_dirichlet_constraint(bnd_marker, dirichlet_function, on_boundary=True)` then `set_constraint_relation()`; `constrain_matrix()` applies Dirichlet + hanging-node constraints. Keep Galerkin (same trial/test) when using these utilities.
- **Hanging nodes**: `DofHandler.set_hanging_nodes` is invoked by `LinearSystem`; constrained DOFs mapped via `constraints` dict. Don’t bypass constraint resolution when solving.
- **SPD utilities**: For covariance/precision matrices use `SPDMatrix`/`CholeskyDecomposition`; sparse path uses CHOLMOD (`sksparse.cholmod`). If not PD, code falls back to modified LDLT (`modchol_ldlt`).
- **GMRF**: `gmrf.py` hosts covariance kernels (`gaussian`, `exponential`, `matern`, etc.), KL tools, and assembly helpers; relies on assembler/basis stack. Wishlist in `notes.txt` shows ongoing work—treat as aspirational.
- **Plotting**: `Plot.mesh/contour/surface` visualize meshes/functions; expects mesh methods (`bounding_box`, `cells.get_leaves`). Quickview shows figures immediately; supply `axis` to embed.
- **Testing**: `pytest` not set up; tests use `unittest`. Run selectively, ensuring path is set: e.g. `PYTHONPATH=$(pwd)/src python -m unittest tests.test_assembler.test_assembler`. Some tests are stubbed (`pass`).
- **Conventions/pitfalls**: Many routines expect numpy arrays with shape (n,dim); `convert_to_array` handles tuples/Vertices—use it. Element dim must match mesh. Flags drive region-specific assembly; set `mark` on cells/half-edges before `shape_info`. Quadrature orders limited (1/2/3/4/5/6 in 1D; 1/4/9/16/25/36 quads; 1/3/7/13 triangles). `DQ*` elements are torn; continuity not enforced across interfaces.
- **External deps**: numpy, scipy (sparse/linalg), matplotlib (plotting), scikit-sparse (CHOLMOD). Install before running examples/tests.
- **Examples**: See `experiments/` for PDE/GMRF demos; `tests/test_assembler/*` for shape/assembly patterns; `add_path.py` shows path injection used in tests.
